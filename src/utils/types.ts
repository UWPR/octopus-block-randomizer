import { ALGORITHM_CONFIG, QUALITY_LEVEL_CONFIG, QualityLevel } from './configs';

// Block types for distribution algorithms
export enum BlockType {
  PLATE = 'Plate',
  ROW = 'Row'
}

export interface SearchData {
  name: string;
  metadata: { [key: string]: string };
}

export type RandomizationAlgorithm = keyof typeof ALGORITHM_CONFIG;

// Utility functions for algorithm configuration
export const getAlgorithmName = (algorithm: RandomizationAlgorithm): string =>
  ALGORITHM_CONFIG[algorithm].name;

export const getAlgorithmDescription = (algorithm: RandomizationAlgorithm): string =>
  ALGORITHM_CONFIG[algorithm].description;

export const getAllAlgorithms = (): RandomizationAlgorithm[] =>
  Object.keys(ALGORITHM_CONFIG) as RandomizationAlgorithm[];

// Get algorithms in UI display order
export const getAlgorithmsInDisplayOrder = (): RandomizationAlgorithm[] =>
  ['balanced', 'greedy'] as RandomizationAlgorithm[];

export interface RandomizationOptions {
  algorithm: RandomizationAlgorithm;
  selectedCovariates: string[];
}

export interface SummaryItem {
  combination: string;
  values: { [key: string]: string };
  count: number;
  color: string;
  useOutline: boolean;
  useStripes: boolean;
}

export interface CovariateColorInfo {
  color: string;
  useOutline: boolean;
  useStripes: boolean;
  textColor: string; // Pre-calculated text color for readability (white or black)
}

// Quality Metrics Levels
export interface QualityLevelConfig {
  name: string;
  shortLabel: string;
  color: string;
  lowScore: number;
  highScore: number;
}

// Utility functions for quality levels
export const getQualityLevelConfig = (level: QualityLevel): QualityLevelConfig =>
  QUALITY_LEVEL_CONFIG[level];

export const getAllQualityLevelKeys = (): QualityLevel[] =>
  Object.keys(QUALITY_LEVEL_CONFIG) as QualityLevel[];

export interface PlateQualityScore {
  plateIndex: number;
  balanceScore: number; // 0-100 (Proportional Accuracy)
  rowClusteringScore: number; // 0-100 (Row Clustering)
  overallScore: number; // 0-100 (Average of both)
  rowScores?: number[]; // Individual row scores (0-100)
  covariateGroupBalance: {
    [combination: string]: {
      actualCount: number;
      expectedCount: number;
      actualProportion: number;
      expectedProportion: number;
      relativeDeviation: number;
      weightedDeviation: number;
      balanceScore: number
    }
  };
}

export interface PlateDiversityMetrics {
  averageBalanceScore: number; // 0-100
  averageRowClusteringScore: number; // 0-100
  plateScores: PlateQualityScore[];
}

export interface OverallQualityAssessment {
  score: number; // 0-100
  level: QualityLevel;
  recommendations: string[];
}

export interface QualityMetrics {
  plateDiversity: PlateDiversityMetrics;
  overallQuality: OverallQualityAssessment;
}

// Repeated-measures interfaces

/**
 * Represents a group of samples from the same subject that must stay together on the same plate.
 *
 * In repeated-measures experimental designs, samples from the same subject (e.g., same patient,
 * same biological replicate) must be processed together to avoid confounding batch effects with
 * subject-level variation. This interface encapsulates all samples sharing the same subject
 * identifier along with metadata needed for balanced distribution.
 *
 * **Key Concepts:**
 * - **Subject ID:** The shared identifier (e.g., "Patient_001", "Mouse_042") that links samples
 * - **Atomicity:** All samples in a group must be assigned to the same plate (cannot be split)
 * - **Treatment Composition:** Groups can contain samples with different treatment values
 *   (e.g., same patient at different timepoints or under different conditions)
 * - **Singletons:** Samples without a subject ID are treated as independent single-sample groups
 *
 * **Example Scenarios:**
 *
 * 1. **Longitudinal Study:**
 * ```typescript
 * {
 *   subjectId: "Patient_001",
 *   samples: [sample_t0, sample_t1, sample_t2, sample_t3],
 *   treatmentComposition: Map([
 *     ["Drug|Timepoint_0", 1],
 *     ["Drug|Timepoint_1", 1],
 *     ["Drug|Timepoint_2", 1],
 *     ["Drug|Timepoint_3", 1]
 *   ]),
 *   size: 4,
 *   isSingleton: false
 * }
 * ```
 *
 * 2. **Technical Replicates:**
 * ```typescript
 * {
 *   subjectId: "Sample_A",
 *   samples: [rep1, rep2, rep3],
 *   treatmentComposition: Map([["Control|Batch_1", 3]]),
 *   size: 3,
 *   isSingleton: false
 * }
 * ```
 *
 * 3. **Singleton (No Subject ID):**
 * ```typescript
 * {
 *   subjectId: "__singleton_0",
 *   samples: [orphan_sample],
 *   treatmentComposition: Map([["Treatment_X|Condition_Y", 1]]),
 *   size: 1,
 *   isSingleton: true
 * }
 * ```
 *
 * **Treatment Composition Details:**
 * - Maps treatment combination keys (e.g., "Drug|Timepoint_0") to sample counts
 * - Treatment keys are generated by joining treatment variable values with "|"
 * - Used by distribution algorithm to calculate balance scores
 * - Pre-calculated during group creation for performance optimization
 * - Can contain multiple different treatment combinations in one group
 *
 * **Usage in Distribution Algorithm:**
 * 1. Groups are sorted by size (largest first) for better bin packing
 * 2. Each group is assigned to the plate that minimizes treatment imbalance
 * 3. Treatment composition is used to calculate hypothetical balance scores
 * 4. Groups are never split - all samples stay together
 *
 * @see {@link createRepeatedMeasuresGroups} for group creation
 * @see {@link distributeGroupsToPlates} for distribution algorithm
 */
export interface RepeatedMeasuresGroup {
  /**
   * Unique identifier for this group.
   *
   * - For regular groups: The value from the repeated-measures variable (e.g., "Patient_001")
   * - For singletons: Auto-generated unique ID (e.g., "__singleton_0", "__singleton_1")
   *
   * Subject IDs are case-sensitive and must match exactly across samples.
   */
  subjectId: string;

  /**
   * All samples belonging to this group.
   *
   * - For regular groups: 2+ samples sharing the same subject ID
   * - For singletons: Exactly 1 sample without a subject ID
   *
   * All samples in this array will be assigned to the same plate during distribution.
   */
  samples: SearchData[];

  /**
   * Treatment composition of this group.
   *
   * Maps treatment combination keys to the count of samples with that combination.
   * Treatment keys are generated by joining treatment variable values with "|" separator.
   *
   * **Example:**
   * ```typescript
   * Map([
   *   ["Drug|Timepoint_0", 2],    // 2 samples with Drug at Timepoint 0
   *   ["Drug|Timepoint_10", 1],   // 1 sample with Drug at Timepoint 10
   *   ["Placebo|Timepoint_0", 1]  // 1 sample with Placebo at Timepoint 0
   * ])
   * ```
   *
   * **Important Notes:**
   * - A group can contain samples with DIFFERENT treatment values (e.g., different timepoints)
   * - This is expected and correct for longitudinal or multi-condition designs
   * - Pre-calculated during group creation to avoid recalculation during distribution
   * - Used by balance scoring algorithm to evaluate plate assignments
   */
  treatmentComposition: Map<string, number>;

  /**
   * Total number of samples in this group.
   *
   * - For regular groups: 2 or more (typically 2-10, but can be larger)
   * - For singletons: Always 1
   *
   * Used for:
   * - Capacity constraint checking (group.size <= plateCapacity)
   * - Sorting groups for distribution (largest first)
   * - Validation (detecting oversized groups)
   * - Statistics and reporting
   */
  size: number;

  /**
   * Whether this is a singleton group (sample without subject ID).
   *
   * - `true`: Sample had no value (empty, null, or whitespace) for repeated-measures variable
   * - `false`: Sample had a valid subject ID and may be grouped with other samples
   *
   * Singletons are treated as independent units and can be distributed to any plate.
   * They are given unique auto-generated IDs (e.g., "__singleton_0") to distinguish them.
   *
   * High singleton ratios (>80%) may indicate incorrect variable selection.
   */
  isSingleton: boolean;
}

/**
 * Configuration for randomization with optional repeated-measures support.
 *
 * This interface defines all parameters needed for both standard and repeated-measures-aware
 * randomization. When `repeatedMeasuresVariable` is provided, the algorithm uses group-based
 * distribution at the plate level. When omitted, standard sample-based distribution is used.
 *
 * **Example Usage:**
 *
 * Standard randomization (no repeated-measures):
 * ```typescript
 * const config: RandomizationConfig = {
 *   treatmentVariables: ['Treatment', 'Timepoint'],
 *   keepEmptyInLastPlate: true,
 *   numRows: 8,
 *   numColumns: 12
 * };
 * ```
 *
 * Repeated-measures randomization:
 * ```typescript
 * const config: RandomizationConfig = {
 *   treatmentVariables: ['Treatment', 'Timepoint'],
 *   repeatedMeasuresVariable: 'PatientID',
 *   keepEmptyInLastPlate: true,
 *   numRows: 8,
 *   numColumns: 12
 * };
 * ```
 *
 * @see {@link balancedBlockRandomization} for the main randomization function
 */
export interface RandomizationConfig {
  /**
   * Variables used for treatment balancing across plates and rows.
   *
   * These are the metadata field names that define treatment groups to be balanced.
   * The algorithm will attempt to distribute samples proportionally across plates
   * and rows based on all combinations of these variables.
   *
   * **Examples:**
   * - `['Treatment']` - Balance by treatment only
   * - `['Treatment', 'Timepoint']` - Balance by treatment × timepoint combinations
   * - `['Drug', 'Dose', 'Gender']` - Balance by drug × dose × gender combinations
   *
   * **Important:**
   * - Cannot overlap with `repeatedMeasuresVariable` (mutual exclusivity enforced)
   * - Order doesn't matter for balancing but affects combination key generation
   * - All samples must have values for these variables
   */
  treatmentVariables: string[];

  /**
   * Variable used for repeated-measures grouping (optional).
   *
   * When provided, samples sharing the same value for this variable will be grouped
   * together and assigned to the same plate. This is essential for repeated-measures
   * designs where samples from the same subject must be processed together.
   *
   * **Common Use Cases:**
   * - `'PatientID'` - Group samples from same patient
   * - `'SubjectID'` - Group samples from same subject
   * - `'MouseID'` - Group samples from same mouse
   * - `'BiologicalReplicate'` - Group technical replicates
   *
   * **Behavior:**
   * - If provided: Uses repeated-measures-aware randomization algorithm
   * - If omitted: Uses standard randomization algorithm
   * - Samples without a value become independent singletons
   * - Cannot be the same as any treatment variable
   *
   * **Limitations:**
   * - Groups larger than plate capacity will cause an error
   * - Large groups (>50% plate capacity) may limit balancing flexibility
   * - Balance may be less perfect than standard randomization
   */
  repeatedMeasuresVariable?: string;

  /**
   * Whether to keep empty cells in the last plate only.
   *
   * - `true`: Fill plates sequentially, leaving empty cells only in the last plate
   * - `false`: Distribute empty cells randomly across all plates
   *
   * **Example with 200 samples and 96-well plates:**
   * - `true`: Plate 1 = 96 samples, Plate 2 = 96 samples, Plate 3 = 8 samples (88 empty)
   * - `false`: Plate 1 = 67 samples, Plate 2 = 67 samples, Plate 3 = 66 samples
   *
   * Most users prefer `true` to minimize the number of partially filled plates.
   */
  keepEmptyInLastPlate: boolean;

  /**
   * Number of rows per plate.
   *
   * Common values:
   * - 8 rows for 96-well plates (8×12)
   * - 16 rows for 384-well plates (16×24)
   * - 32 rows for 1536-well plates (32×48)
   *
   * Must be > 0.
   */
  numRows: number;

  /**
   * Number of columns per plate.
   *
   * Common values:
   * - 12 columns for 96-well plates (8×12)
   * - 24 columns for 384-well plates (16×24)
   * - 48 columns for 1536-well plates (32×48)
   *
   * Must be > 0.
   */
  numColumns: number;
}

/**
 * Result object returned by randomization functions with optional repeated-measures metadata.
 *
 * This interface represents the complete output of the randomization algorithm, including
 * the final plate layout, plate assignments, and optional repeated-measures-specific metadata.
 * The structure supports both standard and repeated-measures-aware randomization.
 *
 * **Standard Randomization Output:**
 * ```typescript
 * {
 *   plates: [[[sample1, sample2, ...], [...], ...], ...],
 *   plateAssignments: Map([[0, [sample1, sample2, ...]], [1, [...]], ...])
 * }
 * ```
 *
 * **Repeated-Measures Randomization Output:**
 * ```typescript
 * {
 *   plates: [[[sample1, sample2, ...], [...], ...], ...],
 *   plateAssignments: Map([[0, [sample1, sample2, ...]], [1, [...]], ...]),
 *   repeatedMeasuresGroups: [group1, group2, ...],
 *   qualityMetrics: { ... }
 * }
 * ```
 *
 * @see {@link balancedBlockRandomization} for the function that returns this type
 */
export interface RandomizationResult {
  /**
   * 3D array representing the final plate layout.
   *
   * **Structure:** `plates[plateIdx][rowIdx][colIdx] = SearchData | undefined`
   *
   * - First dimension: Plate index (0-based)
   * - Second dimension: Row index (0-based, typically 0-7 for 96-well plates)
   * - Third dimension: Column index (0-based, typically 0-11 for 96-well plates)
   * - Value: Sample object or `undefined` for empty wells
   *
   * **Example Access:**
   * ```typescript
   * const sample = result.plates[0][2][5]; // Plate 1, Row 3, Column 6
   * if (sample) {
   *   console.log(`Well C6 contains: ${sample.name}`);
   * }
   * ```
   *
   * **Empty Wells:**
   * - Represented as `undefined`
   * - Occur when total samples don't fill all plates completely
   * - Location depends on `keepEmptyInLastPlate` setting
   *
   * **Usage:**
   * - Rendering plate visualizations in UI
   * - Exporting to plate layout files
   * - Validating sample positions
   * - Calculating spatial metrics
   */
  plates: (SearchData | undefined)[][][];

  /**
   * Map of plate index to samples assigned to that plate.
   *
   * **Structure:** `Map<plateIndex, samples[]>`
   *
   * Provides a flattened view of plate assignments without row/column information.
   * Useful for:
   * - Calculating plate-level statistics
   * - Validating treatment balance across plates
   * - Checking repeated-measures constraints
   * - Generating plate-level reports
   *
   * **Example:**
   * ```typescript
   * result.plateAssignments?.forEach((samples, plateIdx) => {
   *   console.log(`Plate ${plateIdx + 1}: ${samples.length} samples`);
   * });
   * ```
   *
   * **Note:** Optional field, may be undefined for legacy compatibility.
   */
  plateAssignments?: Map<number, SearchData[]>;

  /**
   * Repeated-measures groups created during randomization.
   *
   * Only present when `repeatedMeasuresVariable` is specified in the configuration.
   * Contains all groups created, including both multi-sample groups and singletons.
   *
   * **Usage:**
   * - Displaying group statistics in UI
   * - Validating that groups stayed together
   * - Analyzing group size distribution
   * - Debugging distribution issues
   *
   * **Example:**
   * ```typescript
   * if (result.repeatedMeasuresGroups) {
   *   const multiSampleGroups = result.repeatedMeasuresGroups.filter(g => !g.isSingleton);
   *   console.log(`Created ${multiSampleGroups.length} multi-sample groups`);
   * }
   * ```
   *
   * **Note:** Undefined for standard randomization (no repeated-measures variable).
   */
  repeatedMeasuresGroups?: RepeatedMeasuresGroup[];

  /**
   * Comprehensive quality metrics for repeated-measures randomization.
   *
   * Only present when `repeatedMeasuresVariable` is specified in the configuration.
   * Includes both repeated-measures-specific metrics and standard quality metrics.
   *
   * **Metrics Included:**
   * - Repeated-measures constraint satisfaction (groups stayed together)
   * - Treatment balance scores across plates
   * - Group size distribution statistics
   * - Per-plate group counts
   * - Standard quality metrics (balance, row clustering)
   *
   * **Usage:**
   * - Displaying quality assessment in UI
   * - Validating randomization quality
   * - Comparing different randomization attempts
   * - Generating quality reports
   *
   * **Example:**
   * ```typescript
   * if (result.qualityMetrics) {
   *   console.log(`Constraints satisfied: ${result.qualityMetrics.repeatedMeasuresConstraintsSatisfied}`);
   *   console.log(`Balance score: ${result.qualityMetrics.treatmentBalanceScore}/100`);
   * }
   * ```
   *
   * **Note:** Undefined for standard randomization (no repeated-measures variable).
   */
  qualityMetrics?: RepeatedMeasuresQualityMetrics;
}

/**
 * Comprehensive quality metrics specific to repeated-measures randomization.
 *
 * This interface extends standard quality metrics with repeated-measures-specific assessments,
 * providing a complete picture of randomization quality including constraint satisfaction,
 * treatment balance, and group distribution statistics.
 *
 * **Quality Assessment Categories:**
 * 1. **Constraint Satisfaction:** Validates that groups stayed together on same plate
 * 2. **Treatment Balance:** Measures how well treatment proportions are maintained
 * 3. **Group Distribution:** Analyzes how groups are distributed across plates
 * 4. **Standard Metrics:** Includes all standard quality assessments
 *
 * **Example Usage:**
 * ```typescript
 * const metrics = result.qualityMetrics;
 *
 * // Check constraint satisfaction
 * if (!metrics.repeatedMeasuresConstraintsSatisfied) {
 *   console.error(`Found ${metrics.repeatedMeasuresViolations} constraint violations!`);
 * }
 *
 * // Assess balance quality
 * if (metrics.treatmentBalanceScore < 70) {
 *   console.warn('Treatment balance is below acceptable threshold');
 * }
 *
 * // Analyze group distribution
 * const totalGroups = Object.values(metrics.groupSizeDistribution)
 *   .reduce((sum, count) => sum + count, 0);
 * console.log(`Total groups: ${totalGroups}`);
 * ```
 *
 * @see {@link calculateRepeatedMeasuresQualityMetrics} for calculation details
 */
export interface RepeatedMeasuresQualityMetrics {
  /**
   * Whether repeated-measures constraints are satisfied.
   *
   * - `true`: All groups stayed together on the same plate (expected)
   * - `false`: One or more groups were split across plates (critical error)
   *
   * This is the most important metric for repeated-measures randomization.
   * If false, the randomization is invalid and should not be used.
   *
   * **Validation Logic:**
   * - Checks that all samples with same subject ID are on same plate
   * - Singletons (no subject ID) are excluded from validation
   * - Any split group counts as a violation
   *
   * **If False:**
   * - Indicates a bug in the distribution algorithm
   * - Randomization should be rejected
   * - Check `repeatedMeasuresViolations` for count of issues
   */
  repeatedMeasuresConstraintsSatisfied: boolean;

  /**
   * Number of groups split across plates.
   *
   * - **Expected value:** 0 (no violations)
   * - **Any value > 0:** Critical error in distribution algorithm
   *
   * Each violation represents one subject ID that appears on multiple plates.
   *
   * **Example:**
   * - If Patient_001 has samples on both Plate 1 and Plate 2, that's 1 violation
   * - If Patient_002 also appears on multiple plates, that's 2 violations total
   *
   * **Note:** This should always be 0 if the algorithm is working correctly.
   */
  repeatedMeasuresViolations: number;

  /**
   * Treatment balance score across plates (0-100, higher is better).
   *
   * Measures how well treatment proportions are maintained across plates compared
   * to the global distribution. Based on the standard balance score calculation.
   *
   * **Score Interpretation:**
   * - **90-100:** Excellent balance (near-perfect proportions)
   * - **70-89:** Good balance (acceptable for most studies)
   * - **50-69:** Fair balance (may be acceptable depending on requirements)
   * - **Below 50:** Poor balance (consider re-randomization)
   *
   * **Factors Affecting Score:**
   * - Large groups limit balancing flexibility (lower scores expected)
   * - Rare treatment combinations are harder to balance
   * - More plates generally allows better balance
   * - Group composition heterogeneity affects achievable balance
   *
   * **Note:** Balance may be less perfect than standard randomization due to
   * the constraint that groups cannot be split across plates.
   */
  treatmentBalanceScore: number;

  /**
   * Number of repeated-measures groups assigned to each plate.
   *
   * Array where index represents plate number (0-based) and value is group count.
   *
   * **Example:**
   * ```typescript
   * [12, 11, 10] // Plate 1: 12 groups, Plate 2: 11 groups, Plate 3: 10 groups
   * ```
   *
   * **Usage:**
   * - Assessing distribution evenness across plates
   * - Identifying plates with unusually high/low group counts
   * - Calculating average groups per plate
   * - Displaying per-plate statistics in UI
   *
   * **Note:** Includes both multi-sample groups and singletons in the count.
   */
  plateGroupCounts: number[];

  /**
   * Distribution of groups by size category.
   *
   * Categorizes all groups into size buckets for statistical analysis.
   *
   * **Categories:**
   * - **singletons:** Samples without subject ID (size = 1, isSingleton = true)
   * - **small:** Multi-sample groups with 2-5 samples
   * - **medium:** Multi-sample groups with 6-15 samples
   * - **large:** Multi-sample groups with 16+ samples
   *
   * **Example:**
   * ```typescript
   * {
   *   singletons: 5,  // 5 samples without subject ID
   *   small: 20,      // 20 groups with 2-5 samples each
   *   medium: 8,      // 8 groups with 6-15 samples each
   *   large: 2        // 2 groups with 16+ samples each
   * }
   * // Total: 35 groups
   * ```
   *
   * **Usage:**
   * - Understanding group composition
   * - Identifying potential balancing challenges (many large groups)
   * - Detecting incorrect variable selection (high singleton ratio)
   * - Generating distribution histograms
   *
   * **Interpretation:**
   * - High singleton count (>80%): May indicate wrong variable selected
   * - Many large groups: May limit balancing flexibility
   * - Mostly small groups: Ideal for balancing
   */
  groupSizeDistribution: {
    /** Number of singleton groups (samples without subject ID) */
    singletons: number;
    /** Number of small groups (2-5 samples) */
    small: number;
    /** Number of medium groups (6-15 samples) */
    medium: number;
    /** Number of large groups (16+ samples) */
    large: number;
  };

  /**
   * Standard quality metrics (balance, row clustering, overall assessment).
   *
   * Includes all the same metrics calculated for standard randomization:
   * - Plate diversity metrics (balance and row clustering scores)
   * - Per-plate quality scores
   * - Overall quality assessment with recommendations
   *
   * **Usage:**
   * - Comparing repeated-measures randomization to standard randomization
   * - Assessing row-level balance within plates
   * - Getting overall quality level (Excellent, Good, Fair, Poor)
   * - Displaying standard quality visualizations
   *
   * @see {@link QualityMetrics} for detailed structure
   */
  standardMetrics: QualityMetrics;
}

